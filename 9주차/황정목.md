# 5.4 Sort Area를 적게 사용하도록 SQL 작성

## 핵심 개념

**Sort Area 최적화의 중요성**
- 소트 연산이 불가피한 경우 메모리 내에서 처리 완료 필수
- Sort Area 사용량 최소화 → 디스크 I/O 감소 → 성능 향상
- Temp Tablespace 사용 방지로 SQL 성능 크게 향상

**최적화 방법**
1. 소트 데이터 줄이기
2. Top N 쿼리 알고리즘 활용
3. 분석함수를 이용한 소트 부하 최소화
4. 필요한 컬럼만 선택

## 5.4.1 소트 데이터 줄이기

### 데이터 가공 시점 최적화

**기본 원리**
소트 전에 데이터 가공하면 가공된 데이터를 Sort Area에 저장해야 하므로 비효율적. 소트 후 가공이 효율적.

**비효율적인 방법**
```sql
-- 가공된 데이터를 Sort Area에 저장
SELECT LPAD(상품번호, 30) || LPAD(상품명, 30) || LPAD(고객id, 10)
  FROM 주문상품
 WHERE 주문일시 BETWEEN :start AND :end
 ORDER BY 상품번호;
```

**효율적인 방법**
```sql
-- 정렬 후 가공
SELECT LPAD(상품번호, 30) || LPAD(상품명, 30) || LPAD(고객id, 10)
  FROM (SELECT 상품번호, 상품명, 고객id
          FROM 주문상품
         WHERE 주문일시 BETWEEN :start AND :end
         ORDER BY 상품번호);
```

### 필요한 컬럼만 선택

```sql
-- 비효율적: 모든 컬럼 선택 (716MB / 14.41sec)
SELECT * FROM 예수금원장 ORDER BY 총예수금 DESC;

-- 효율적: 필요한 컬럼만 선택 (17MB / 1.2sec)
SELECT 계좌번호, 총예수금 FROM 예수금원장 ORDER BY 총예수금 DESC;
```

## 5.4.2 Top N 쿼리의 소트 부하 경감

### Top N 소트 알고리즘

**SORT ORDER BY STOPKEY 동작 원리**
- ROWNUM <= N 조건 시 N개 레코드 배열 할당
- 전체 데이터를 완전 정렬하지 않고 상위 N개만 유지
- 새로운 레코드는 최대값과 비교하여 필요시에만 배열 재정렬

**효과적인 Top N 쿼리 패턴**
```sql
SELECT *
  FROM (SELECT ROWNUM NO, A.*
          FROM (SELECT 거래일시, 체결건수, 체결수량, 거래대금
                  FROM 종목거래
                 WHERE 종목코드 = 'KR123456'
                 ORDER BY 거래일시) A
         WHERE ROWNUM <= (:page * 10))
 WHERE NO >= (:page-1) * 10 + 1;
```

**실행계획 특징**
- `COUNT(STOPKEY)` 오퍼레이션
- `SORT ORDER BY STOPKEY` - Top N 알고리즘 동작
- 인덱스 활용 시 소트 연산 완전 생략 가능

## 5.4.3 Top N 쿼리가 아닐 때의 소트 부하

### 페이징 처리 시 주의사항

**비효율적인 패턴**
```sql
-- ROWNUM 조건이 외부에 있으면 전체 데이터 소트 발생
SELECT *
  FROM (SELECT ROWNUM NO, A.*
          FROM (SELECT 거래일시, 체결건수
                  FROM 종목거래
                 ORDER BY 거래일시) A)
 WHERE NO BETWEEN (:page-1) * 10 + 1 AND (:page * 10);
-- 실행계획: SORT ORDER BY (전체 소트)
```

**효율적인 패턴**
```sql
-- ROWNUM 조건이 내부에 있어야 STOPKEY 적용
SELECT *
  FROM (SELECT ROWNUM NO, A.*
          FROM (SELECT 거래일시, 체결건수
                  FROM 종목거래
                 ORDER BY 거래일시) A
         WHERE ROWNUM <= (:page * 10))
 WHERE NO >= (:page-1) * 10 + 1;
-- 실행계획: SORT ORDER BY STOPKEY (Top N 알고리즘)
```

## 5.4.4 분석함수에서의 Top N 소트

### 분석함수 활용 최적화

**최근 이력 조회 최적화**
```sql
-- 효율적: 윈도우 함수 활용
SELECT *
  FROM (SELECT 상품코드, 상품명, 가격, 변경일시,
               ROW_NUMBER() OVER (PARTITION BY 상품코드 ORDER BY 변경일시 DESC) RN
          FROM 상품이력)
 WHERE RN = 1;
```

**MAX() 함수 대신 분석함수 사용**
```sql
-- 비효율적: MAX() 함수
SELECT * FROM 상품이력 A
 WHERE 변경일시 = (SELECT MAX(변경일시) FROM 상품이력 B
                   WHERE B.상품코드 = A.상품코드);

-- 효율적: ROW_NUMBER() 사용
SELECT *
  FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY 상품코드 ORDER BY 변경일시 DESC) RN
          FROM 상품이력)
 WHERE RN = 1;
```

### 분석함수 활용 전략

**성능 최적화 방법**
- `ROW_NUMBER()`, `RANK()` 등이 MAX() 함수보다 소트 부하 적음
- `PARTITION BY`로 그룹별 처리하여 소트 범위 최소화
- 적절한 인덱스 구성으로 윈도우 함수 소트 부하 최소화

**튜닝 가이드**
1. PARTITION BY와 ORDER BY 절에 해당하는 인덱스 구성
2. 윈도우 함수로 서브쿼리 복잡성 제거
3. 집계 함수 대신 분석함수 사용
4. 이력 데이터 조회 시 분석함수 적극 활용

## 핵심 포인트

- 소트 전 데이터 가공 최소화
- 필요한 컬럼만 선택하여 소트 대상 크기 최소화
- Top N 쿼리에서 ROWNUM 조건 위치 주의
- 분석함수 활용으로 소트 부하 경감
- 인덱스 구성으로 소트 연산 생략 가능
