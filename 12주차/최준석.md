# 6.4 Lock과 트랜잭션 동시성 제어

## 핵심 개념 정리

**Lock과 트랜잭션 동시성 제어의 중요성**

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 다양한 종류의 Lock을 사용하며, 동시에 수행되는 트랜잭션들 간의 동시성을 제어하여 데이터 정합성을 보장함. 동시성 제어 방식과 채번 방식에 따라 INSERT 성능에 큰 차이가 발생할 수 있음.

**Lock과 동시성 제어의 핵심 원리**

1. 다양한 Lock 메커니즘을 통한 데이터 보호
2. 비관적/낙관적 동시성 제어 방식 선택
3. 채번 방식에 따른 성능 차이 이해
4. 교착상태 방지 및 해결 방안

## 6.4.1 오라클 Lock

### Lock의 종류와 역할

**1. 래치(Latch)**

SGA에 공유된 각종 자료구조를 보호하기 위해 사용

- 기본적으로 Exclusive 모드를 사용하여 한 순간에 하나의 프로세스만 래치 보유 가능
- 특정 래치에 대해서는 Shared 모드도 사용

**2. 버퍼 Lock**

버퍼 블록에 대한 액세스를 직렬화 하기 위해 사용

- 래치를 해제한 상태로 버퍼블록 데이터를 읽고 쓰는 도중 후행 프로세스의 접근으로 인한 데이터 정합성 문제 방지
- 프로세스가 래치 획득 → 버퍼 접근 → 래치 해제 과정에서 동시 접근 제어

**3. 라이브러리 캐시 Lock과 Pin**

라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용

- Library cache lock 획득 후 추가 작업이 필요할 때 library cache pin 획득

### DML Lock

**DML 로우 Lock**

두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지, 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 함

- 오라클은 로우 Lock에 항상 배타적 모드를 사용
- FOR UPDATE절을 통해 나중에 갱신할 수 있는 컬럼만 포함하여 결과 세트 제한

**테이블 Lock (TM Lock)**

현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서 DML 로우 Lock을 설정하기에 앞서 테이블 Lock(TM Lock)을 먼저 설정한다

- 오라클에서 테이블 Lock은 자신이 해당 테이블에서 현재 어떤 작업을 수행 중인지를 알리는 일종의 푯말(Flag)
- 여러 가지 Lock 모드를 사용하여 선행 트랜잭션과의 호환성 검사

### Lock 대기 및 처리 옵션

**Lock 대기 방식**

Lock을 얻고자 하는 리소스가 사용중일 때 프로세스는 세 가지 방법 중 하나를 선택:

1. **WAIT**: Lock이 해제될 때까지 기다림
2. **WAIT n**: 일정 시간만 기다리다 포기 (`select * from t for update wait 3`)
3. **NOWAIT**: 기다리지 않고 작업을 포기 (`select * from t for update nowait`)

**교착상태 처리**

교착상태가 발생하면, 트랜잭션이 문장 수준 롤백을 진행한 후 에러 메시지를 던진다. (교착상태를 발생시킨 문장 하나만 롤백)

- ORA-00060: deadlock detected while waiting for resource
- 교착상태 해소 후 블로킹 상태가 되므로 커밋 또는 롤백 결정 필요

## 6.4.2 트랜잭션 동시성 제어

### 비관적 동시성 제어 (Pessimistic Concurrency Control)

**기본 개념**

사용자들이 같은 데이터를 동시에 수정할 것으로 간주 따라서, 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지

**구현 방법**

```sql
-- FOR UPDATE를 통한 Lock 설정
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적
FROM 고객
WHERE 고객번호 = :cust_num
FOR UPDATE;

-- 새로운 적립포인트 계산 후 UPDATE
UPDATE 고객 SET 적립포인트 = :적립포인트
WHERE 고객번호 = :cust_num;
```

**장단점**

- 장점: 데이터 정합성 확실히 보장
- 단점: 시스템 동시성을 심각하게 떨어뜨릴 우려
- 개선: FOR UPDATE에 WAIT 또는 NOWAIT 옵션 사용으로 동시성 증가

### 낙관적 동시성 제어 (Optimistic Concurrency Control)

**기본 개념**

사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정

**구현 방법**

```sql
-- 1. 조회 시점의 값 저장
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적
INTO :a, :b, :c, :d
FROM 고객 WHERE 고객번호 = :cust_num;

-- 2. 업데이트 시 원래 값과 비교하여 변경 여부 확인
UPDATE 고객 SET 적립포인트 = :적립포인트
WHERE 고객번호 = :cust_num
AND 적립포인트 = :a
AND 방문횟수 = :b
AND 최근방문일시 = :c
AND 구매실적 = :d;
```

**최종변경일시를 활용한 간단한 방법**

```sql
-- 최종 변경일시가 앞서 읽은 값과 같은지 비교
UPDATE 고객 SET 적립포인트 = :적립포인트, 변경일시 = SYSDATE
WHERE 고객번호 = :cust_num
AND 변경일시 = :mod_dt;
```

**장단점**

- 장점: Lock 유지 시간이 매우 짧아 동시성 향상에 유리
- 단점: 다른 사용자의 변경 검사 및 처리 방향 결정 절차 필요

## 6.4.3 채번 방식에 따른 INSERT 성능 비교

### INSERT의 중요성

INSERT, UPDATE, DELETE, MERGE 중 가장 중요하고 튜닝요소가 많은 것은 INSERT 수행빈도가 가장 높고, 채번 방식에 따른 성능 차이가 매우 크기 때문이다

**용어 정의**

- **구분 속성**: PK가 복합컬럼일 때 순번 이외의 컬럼 (예: 상담원ID + 상담일자 + 상담순번에서 상담원ID, 상담일자)

### 1. 채번 테이블 방식

**메커니즘**

각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식

- 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드 입력에 사용

**장점**

- 논리적 일련번호 보장
- 설정 변경 없이 사용 가능

**단점**

가장 큰 단점은 다른 채번 방식에 비해 성능이 안좋다는 데 있다. 채번 레코드를 변경하기 위한 로우 Lock 경합 때문!

- 로우 Lock이 커밋 또는 롤백까지 지속
- 동시 INSERT가 많으면 채번 테이블 블록 자체에도 경합 발생

**자율 트랜잭션 활용**

- PL/SQL의 pragma autonomous_transaction 선언으로 메인 트랜잭션에 영향 없이 서브 트랜잭션에서 일부 자원만 Lock 해제

### 2. 시퀀스 오브젝트 방식

**장점**

가장 큰 장점은 성능이 빠르다는데 있다

- 중복 레코드 발생에 대비한 예외처리에 크게 신경쓰지 않아도 됨
- 개발팀 입장에서 사용하기 편리

**시퀀스 Lock 메커니즘**

1. **로우 캐시 Lock**: 딕셔너리 정보를 로우 캐시에서 읽고 쓸 때 액세스 직렬화를 위한 Lock
2. **시퀀스 캐시 Lock (SQ Lock)**: 시퀀스 캐시에서 값을 얻을 때 액세스 직렬화를 위한 Lock
3. **SV Lock**: RAC 환경에서 시퀀스 캐시 공유를 위한 Lock

**성능 최적화 방안**

```sql
-- CACHE 옵션을 통한 로우 캐시 Lock 경합 감소
CREATE SEQUENCE MTSEQ CACHE 1000;
```

- 기본값 20을 큰 값으로 설정하여 경합 감소
- ORDER 옵션은 업무적으로 꼭 필요한 경우에만 사용

**순환 시퀀스 활용**

- PK가 복합컬럼이고 동시 트랜잭션이 높은 경우 순환(cycle) 옵션 고려
- 최대값 도달 시 1부터 다시 시작

**결번 방지**

```sql
-- 시퀀스를 Shared Pool에 KEEP
EXEC SYS.DBMS_SHARED_POOL.KEEP('SCOTT.MT_SEQ','Q');
```

### 3. MAX + 1 방식

**메커니즘**

대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT 하는 방식

**장점**

- 별도 오브젝트 생성 및 관리 부담 없음
- 논리적 일련번호 보장

**단점**

- 성능이 가장 느림
- 중복 레코드 발생 가능성으로 예외처리 필수

### Lock 경합 해결 방안

**채번 방식 선택 기준**

동시 트랜잭션 수준에 따른 채번 방식 선택:

- 낮음: MAX + 1 방식 가능
- 보통: 시퀀스 오브젝트 권장
- 높음: 시퀀스 + 적절한 CACHE 설정
- 매우 높음: 입력일시를 PK에 포함하는 구조 설계

**PK 구조 개선**

한 개 이상의 구분 속성과 함께 뒤쪽에 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계하면, 채번 또는 INSERT 과정에 생기는 Lock 이슈를 거의 해소할 수 있다

### 인덱스 블록 경합

**Right Growing 인덱스 문제**

Right Growing 인덱스에는 입력하는 값이 달라도 같은 블록을 갱신하려는 프로세스 간 버퍼 Lock 경합이 발생할 수 있고, 이는 여러 프로세스에 의한 동시 INSERT가 많을 때 트랜잭션 성능을 떨어뜨리는 주범이다

**해결 방안**

인덱스 블록 경합을 해소하는 가장 일반적인 방법은 인덱스를 해시 파티셔닝 하는 것이다

- 순차적으로 증가하는 값도 해시 함수에 따라 서로 다른 파티션에 입력되어 경합 감소

**커밋 최적화**

```sql
-- 비동기식 커밋과 배치 커밋 활용
COMMIT WRITE IMMEDIATE WAIT;     -- 동기식 커밋 (기본값)
COMMIT WRITE IMMEDIATE NOWAIT;   -- 비동기식 커밋
COMMIT WRITE BATCH WAIT;         -- 배치 커밋
COMMIT WRITE BATCH NOWAIT;       -- 비동기 배치 커밋
```

- WAIT: LGWR의 완료 메시지를 기다림
- NOWAIT: LGWR의 완료 메시지를 기다리지 않고 다음 트랜잭션 진행
- IMMEDIATE: 커밋 명령마다 LGWR가 로그 버퍼를 파일에 기록
- BATCH: 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리

## 튜닝 가이드

1. **적절한 동시성 제어 방식 선택**: 업무 특성에 따라 비관적/낙관적 동시성 제어 방식 결정
2. **채번 방식 최적화**: 동시 트랜잭션 수준에 맞는 채번 방식 선택 및 시퀀스 CACHE 크기 조정
3. **Lock 경합 최소화**: Right Growing 인덱스의 해시 파티셔닝을 통한 블록 경합 해소
4. **PK 구조 개선**: 입력일시를 포함한 PK 구조로 Lock 이슈 근본적 해결
5. **적절한 커밋 전략**: 비동기식 커밋과 배치 커밋을 통한 성능 개선
