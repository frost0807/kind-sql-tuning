# 7장. SQL 옵티마이저

## 핵심 개념

**SQL 옵티마이저의 역할**
- SQL문을 가장 효율적으로 수행할 실행계획 수립
- 통계정보를 바탕으로 한 비용 기반 최적화
- 다양한 실행 경로 중 최저 비용 경로 선택
- 개발자 대신 최적의 데이터 액세스 방법 결정

**옵티마이저 이해의 중요성**
- SQL 튜닝의 핵심은 옵티마이저 원리 이해
- 실행계획 분석을 통한 성능 문제 진단
- 힌트와 통계정보 관리를 통한 성능 최적화
- 옵티마이저 한계 인식과 보완 방법 습득

# 7.1 통계정보와 비용 계산 원리

## 7.1.1 선택도와 카디널리티

### 선택도 (Selectivity)

**선택도의 정의**
- 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율
- 0과 1 사이의 값으로 표현 (0% ~ 100%)
- 옵티마이저가 실행계획 수립 시 가장 중요한 지표

**선택도 계산 공식**
```sql
-- 기본 선택도 계산
선택도 = 선택된 레코드 수 / 전체 레코드 수

-- 예시: 전체 고객 1000명 중 서울 거주 고객 200명
-- WHERE 지역 = '서울'의 선택도 = 200/1000 = 0.2 (20%)
```

**조건별 선택도 계산**

**1. 등치 조건 (=)**
```sql
-- Distinct Value가 있는 경우
선택도 = 1 / NDV (Number of Distinct Values)

-- 예시: 성별 컬럼 (남, 여 2개 값)
-- WHERE 성별 = '남'의 선택도 = 1/2 = 0.5 (50%)
```

**2. 범위 조건 (BETWEEN, >, <)**
```sql
-- 날짜 범위 조건 예시
SELECT * FROM 주문 
WHERE 주문일자 BETWEEN '2023-01-01' AND '2023-01-31';

-- 선택도 계산: (종료값 - 시작값) / (최대값 - 최소값)
-- 1개월 / 전체 기간 비율로 계산
```

**3. 복합 조건**
```sql
-- AND 조건: 선택도 곱셈
-- WHERE 지역 = '서울' AND 성별 = '남'
-- 선택도 = 0.2 × 0.5 = 0.1 (10%)

-- OR 조건: 선택도 덧셈 후 교집합 제외
-- WHERE 지역 = '서울' OR 성별 = '남'
-- 선택도 = 0.2 + 0.5 - (0.2 × 0.5) = 0.6 (60%)
```

### 카디널리티 (Cardinality)

**카디널리티의 정의**
- 특정 액세스 단계에서 나오는 결과 집합의 크기
- 선택도에 전체 로우 수를 곱한 값
- 실행계획의 각 단계별 예상 로우 수

**카디널리티 계산**
```sql
카디널리티 = 전체 로우 수 × 선택도

-- 예시: 고객 테이블 1,000,000건
-- WHERE 지역 = '서울' (선택도 0.2)
-- 카디널리티 = 1,000,000 × 0.2 = 200,000건
```

**카디널리티의 중요성**
- 조인 방식 결정 (NL vs Hash vs Sort Merge)
- 인덱스 사용 여부 결정
- 병렬 처리 degree 결정
- 메모리 할당량 결정

## 7.1.2 통계정보

### 통계정보의 종류

**1. 테이블 통계정보**
```sql
-- 테이블 통계정보 조회
SELECT table_name, num_rows, blocks, avg_row_len,
       last_analyzed, sample_size
FROM user_tables 
WHERE table_name = 'CUSTOMER';
```

**주요 항목**
- NUM_ROWS: 테이블 총 로우 수
- BLOCKS: 테이블이 사용하는 블록 수
- AVG_ROW_LEN: 평균 로우 길이
- LAST_ANALYZED: 마지막 통계정보 수집 일시

**2. 컬럼 통계정보**
```sql
-- 컬럼 통계정보 조회
SELECT column_name, num_distinct, density,
       num_nulls, low_value, high_value,
       histogram
FROM user_tab_col_statistics 
WHERE table_name = 'CUSTOMER';
```

**주요 항목**
- NUM_DISTINCT: 서로 다른 값의 개수 (NDV)
- DENSITY: 밀도 (일반적으로 1/NDV)
- NUM_NULLS: NULL 값의 개수
- LOW_VALUE/HIGH_VALUE: 최소값/최대값
- HISTOGRAM: 히스토그램 정보

**3. 인덱스 통계정보**
```sql
-- 인덱스 통계정보 조회
SELECT index_name, num_rows, distinct_keys,
       leaf_blocks, clustering_factor,
       last_analyzed
FROM user_indexes 
WHERE table_name = 'CUSTOMER';
```

**주요 항목**
- DISTINCT_KEYS: 인덱스의 서로 다른 키 값 개수
- LEAF_BLOCKS: 리프 블록 수
- CLUSTERING_FACTOR: 클러스터링 팩터 (테이블과의 정렬 일치도)

### 통계정보 수집

**1. 자동 통계정보 수집**
```sql
-- 자동 통계정보 수집 작업 확인
SELECT client_name, status, consumer_group
FROM dba_autotask_client
WHERE client_name = 'auto optimizer stats collection';
```

**2. 수동 통계정보 수집**
```sql
-- 테이블 통계정보 수집
EXEC DBMS_STATS.GATHER_TABLE_STATS(
    ownname => 'SCOTT',
    tabname => 'CUSTOMER',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE AUTO',
    degree => 4
);

-- 스키마 전체 통계정보 수집
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname => 'SCOTT',
    estimate_percent => 10,
    degree => 4,
    cascade => TRUE
);
```

**히스토그램 수집**
```sql
-- 히스토그램이 필요한 컬럼 지정
EXEC DBMS_STATS.GATHER_TABLE_STATS(
    ownname => 'SCOTT',
    tabname => 'CUSTOMER',
    method_opt => 'FOR COLUMNS 지역 SIZE 254'
);
```

### 통계정보 관리 전략

**수집 주기**
- OLTP 시스템: 주간 또는 월간
- DW 시스템: 데이터 로드 후 즉시
- 파티션 테이블: 파티션별 수집 고려

**샘플링 비율**
- 일반적으로 10-20% 샘플링으로 충분
- 데이터 분포가 균등하지 않은 경우 더 높은 비율 필요
- AUTO_SAMPLE_SIZE 사용 권장

## 7.1.3 비용 계산 원리

### 비용 계산 모델

**비용의 정의**
- SQL문 실행에 필요한 예상 자원 사용량
- 주로 I/O 비용과 CPU 비용으로 구성
- 상대적 비용으로 절대값보다는 비교값이 중요

**기본 비용 계산 공식**
```sql
총 비용 = I/O 비용 + CPU 비용

I/O 비용 = (Single Block I/O 횟수 × sreadtim) + 
          (Multi Block I/O 횟수 × mreadtim)

CPU 비용 = (CPU 사용량 × cpuspeed) / cpu_cost_ratio
```

### 액세스 방법별 비용 계산

**1. Table Full Scan 비용**
```sql
-- 비용 = 테이블 블록 수 / multiblock_read_count
-- 예시: 테이블 1000블록, MBRC=8
-- 비용 = 1000 / 8 = 125
```

**2. Index Scan 비용**
```sql
-- Index Range Scan 비용
-- = (인덱스 리프 블록 수 × 선택도) + 
--   (테이블 액세스 비용)

-- 예시 계산
-- 인덱스 리프 블록: 100
-- 선택도: 0.1 (10%)
-- 클러스터링 팩터: 800
-- 비용 = (100 × 0.1) + (800 × 0.1) = 90
```

**3. 조인 비용**
```sql
-- Nested Loop Join 비용
-- = Outer Table 비용 + 
--   (Outer 카디널리티 × Inner Table 액세스 비용)

-- Hash Join 비용  
-- = Build Table 비용 + Probe Table 비용 + 
--   Hash Table 생성 비용
```

### 비용에 영향을 미치는 요소

**1. 시스템 통계정보**
```sql
-- 시스템 통계정보 조회
SELECT pname, pval1, pval2 
FROM sys.aux_stats$ 
WHERE sname = 'SYSSTATS_MAIN';
```

**주요 파라미터**
- sreadtim: 단일 블록 읽기 시간
- mreadtim: 다중 블록 읽기 시간  
- cpuspeed: CPU 속도
- mbrc: multiblock read count

**2. 옵티마이저 파라미터**
```sql
-- 주요 파라미터 확인
SELECT name, value FROM v$parameter 
WHERE name IN (
    'optimizer_mode',
    'optimizer_index_cost_adj',
    'optimizer_index_caching',
    'hash_area_size'
);
```

# 7.2 옵티마이저에 대한 이해

## 7.2.1 옵티마이저 종류

### Rule Based Optimizer (RBO)

**RBO의 특징**
- 사전에 정의된 규칙에 따라 실행계획 결정
- 통계정보 사용하지 않음
- 15가지 우선순위 규칙 적용
- 현재는 사용하지 않음 (Oracle 10g부터 지원 중단)

**RBO 우선순위 (참고용)**
1. Single Row by Rowid
2. Single Row by Cluster Join
3. Single Row by Hash Cluster Key
4. Single Row by Unique or Primary Key
5. Clustered Join
6. Hash Cluster Key
7. Indexed Cluster Key
8. Composite Index
9. Single-Column Index
10. Bounded Range Search on Indexed Columns
11. Unbounded Range Search on Indexed Columns
12. Sort Merge Join
13. MAX or MIN of Indexed Column
14. ORDER BY on Indexed Column
15. Full Table Scan

### Cost Based Optimizer (CBO)

**CBO의 특징**
- 통계정보를 바탕으로 비용 계산
- 다양한 실행 경로의 비용을 비교하여 최적 경로 선택
- 동적으로 변화하는 데이터 분포에 적응
- 현재 오라클의 기본 옵티마이저

**CBO 작동 원리**
1. SQL 파싱 및 구문 분석
2. 가능한 모든 실행계획 생성
3. 각 실행계획의 비용 계산
4. 최저 비용 실행계획 선택
5. 실행계획 캐시에 저장

## 7.2.2 옵티마이저 모드

### 옵티마이저 모드 종류

**1. ALL_ROWS (기본값)**
```sql
-- 전체 결과집합을 가장 빠르게 처리하는 실행계획 선택
ALTER SESSION SET OPTIMIZER_MODE = ALL_ROWS;

-- 특징
-- - 전체 처리량 최적화
-- - Full Table Scan 선호 경향
-- - 배치 처리에 적합
```

**2. FIRST_ROWS_n**
```sql
-- 처음 n개 로우를 가장 빠르게 가져오는 실행계획 선택
ALTER SESSION SET OPTIMIZER_MODE = FIRST_ROWS_1;
ALTER SESSION SET OPTIMIZER_MODE = FIRST_ROWS_10;
ALTER SESSION SET OPTIMIZER_MODE = FIRST_ROWS_100;
ALTER SESSION SET OPTIMIZER_MODE = FIRST_ROWS_1000;

-- 특징
-- - 부분 처리량 최적화
-- - Index Scan 선호 경향
-- - 온라인 화면 조회에 적합
```

**3. CHOOSE (Deprecated)**
- 통계정보 존재 여부에 따라 CBO/RBO 선택
- 현재는 사용하지 않음

### 힌트를 통한 옵티마이저 모드 지정

```sql
-- ALL_ROWS 힌트
SELECT /*+ ALL_ROWS */ * FROM 고객 
WHERE 지역 = '서울';

-- FIRST_ROWS 힌트  
SELECT /*+ FIRST_ROWS(10) */ * FROM 고객 
WHERE 지역 = '서울'
ORDER BY 고객번호;
```

## 7.2.3 옵티마이저에 영향을 미치는 요소

### 1. 통계정보

**통계정보의 정확성**
- 부정확한 통계정보 → 잘못된 실행계획
- 정기적인 통계정보 갱신 필요
- 히스토그램을 통한 데이터 분포 정보 제공

**통계정보 확인**
```sql
-- 테이블 통계정보 최신 여부 확인
SELECT table_name, last_analyzed,
       TRUNC(SYSDATE - last_analyzed) AS days_old,
       num_rows, sample_size
FROM user_tables 
WHERE last_analyzed < SYSDATE - 7;
```

### 2. 초기화 파라미터

**주요 파라미터**
```sql
-- 옵티마이저 관련 파라미터 확인
SELECT name, value, description 
FROM v$parameter 
WHERE name LIKE '%optimizer%'
OR name LIKE '%_cost%'
OR name LIKE '%_area_size%';
```

**중요 파라미터**
- `optimizer_mode`: 옵티마이저 모드
- `optimizer_index_cost_adj`: 인덱스 비용 조정 (기본값 100)
- `optimizer_index_caching`: 인덱스 캐싱 비율
- `hash_area_size`: 해시 조인용 메모리
- `sort_area_size`: 정렬용 메모리

### 3. 바인드 변수와 SQL 구조

**바인드 변수 사용**
```sql
-- 바인드 변수 사용 (권장)
SELECT * FROM 고객 WHERE 고객번호 = :customer_id;

-- 리터럴 사용 (비권장)
SELECT * FROM 고객 WHERE 고객번호 = '1001';
```

**SQL 구조의 영향**
- 조인 순서와 조건절 위치
- 서브쿼리 vs 조인
- EXISTS vs IN
- UNION vs UNION ALL

## 7.2.4 옵티마이저의 한계

### 1. 통계정보의 한계

**부정확한 추정**
```sql
-- 복합 조건에서의 추정 오류
SELECT * FROM 고객 
WHERE 지역 = '서울' 
AND 나이 BETWEEN 20 AND 30 
AND 직업 = '학생';
-- 컬럼 간 상관관계를 고려하지 못함
```

**해결 방법**
- 다차원 히스토그램 생성
- SQL 프로파일 사용
- 힌트를 통한 보정

### 2. 바인드 변수 Peeking 문제

**문제 상황**
```sql
-- 처음 실행 시 바인드 값이 '서울'이면 인덱스 선택
-- 나중에 '제주'로 실행해도 동일한 실행계획 사용
SELECT * FROM 고객 WHERE 지역 = :region;
```

**해결 방법**
- Adaptive Cursor Sharing (11g+)
- SQL Plan Baseline
- 힌트 사용

### 3. 동적 성능 이슈

**런타임 환경 변화**
- 메모리 사용률 변화
- I/O 성능 변화  
- 동시 사용자 수 변화
- 데이터 분포 변화

**대응 방안**
- 정기적인 성능 모니터링
- 동적 파라미터 조정
- 실행계획 정기 검토

## 7.2.5 개발자의 역할

### 효율적인 SQL 작성

**1. 조건절 최적화**
```sql
-- 좋은 예: 선택도가 낮은 조건 먼저
SELECT * FROM 주문 
WHERE 주문상태 = '취소'    -- 선택도 1%
AND 주문일자 >= SYSDATE-7;  -- 선택도 10%

-- 나쁜 예: 선택도가 높은 조건 먼저  
SELECT * FROM 주문 
WHERE 주문일자 >= SYSDATE-7  -- 선택도 10%
AND 주문상태 = '취소';       -- 선택도 1%
```

**2. 조인 최적화**
```sql
-- 효율적인 조인 순서
SELECT /*+ LEADING(a,b,c) */ 
       a.고객명, b.주문번호, c.상품명
FROM 고객 a, 주문 b, 주문상품 c
WHERE a.고객번호 = b.고객번호
AND b.주문번호 = c.주문번호
AND a.지역 = '서울';  -- 가장 선택도가 낮은 조건
```

### 실행계획 분석 능력

**1. 실행계획 확인 방법**
```sql
-- 실행계획 확인
EXPLAIN PLAN FOR
SELECT * FROM 고객 WHERE 지역 = '서울';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 실제 실행 통계 포함
SELECT /*+ GATHER_PLAN_STATISTICS */ 
       * FROM 고객 WHERE 지역 = '서울';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null,null,'ALLSTATS LAST'));
```

**2. 실행계획 해석**
- 카디널리티 추정 정확성 확인
- 조인 방식의 적절성 판단
- 인덱스 사용 여부 검토
- 비용과 실제 수행시간 비교

### 힌트 활용

**주요 힌트 종류**
```sql
-- 액세스 방법 힌트
SELECT /*+ FULL(t) */ * FROM 고객 t;
SELECT /*+ INDEX(t, idx_고객_지역) */ * FROM 고객 t;

-- 조인 방법 힌트
SELECT /*+ USE_NL(a,b) */ * FROM 고객 a, 주문 b;
SELECT /*+ USE_HASH(a,b) */ * FROM 고객 a, 주문 b;

-- 조인 순서 힌트
SELECT /*+ LEADING(a,b,c) */ * FROM 고객 a, 주문 b, 상품 c;

-- 병렬 처리 힌트
SELECT /*+ PARALLEL(t,4) */ * FROM 대용량테이블 t;
```

## 7.2.6 튜닝 전문가 되는 공부방법

### 1. 기본기 습득

**필수 지식**
- 오라클 아키텍처 이해
- 인덱스 구조와 원리
- 조인 알고리즘 이해
- 실행계획 읽는 방법
- 대기 이벤트 분석

**추천 학습 순서**
1. SQL 기본 문법 완전 숙달
2. 인덱스 구조와 동작 원리
3. 조인 알고리즘 상세 이해
4. 실행계획 분석 기법
5. 옵티마이저 동작 원리

### 2. 실무 경험 축적

**실습 환경 구성**
```sql
-- 테스트 데이터 생성
CREATE TABLE 고객_대용량 AS
SELECT LEVEL AS 고객번호,
       '고객' || LEVEL AS 고객명,
       CASE MOD(LEVEL, 4) 
           WHEN 0 THEN '서울'
           WHEN 1 THEN '부산' 
           WHEN 2 THEN '대구'
           ELSE '기타'
       END AS 지역,
       SYSDATE - MOD(LEVEL, 365) AS 가입일자
FROM DUAL CONNECT BY LEVEL <= 1000000;

-- 통계정보 수집
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, '고객_대용량');
```

**실습 과제**
- 다양한 조건절로 성능 테스트
- 인덱스 생성 전후 성능 비교
- 힌트 적용 전후 실행계획 비교
- 통계정보 변경에 따른 영향 분석

### 3. 지속적인 학습

**성능 모니터링 도구 활용**
```sql
-- AWR 리포트 생성
@$ORACLE_HOME/rdbms/admin/awrrpt.sql

-- SQL 모니터링
SELECT /*+ MONITOR */ * FROM 대용량테이블;

-- 실시간 SQL 모니터링 조회
SELECT sql_id, status, elapsed_time, cpu_time
FROM v$sql_monitor 
WHERE status = 'EXECUTING';
```

**커뮤니티 활동**
- 전문가 블로그 구독
- 온라인 포럼 참여  
- 컨퍼런스 참석
- 스터디 그룹 활동

### 4. 실전 튜닝 방법론

**체계적 접근법**
1. **문제 정의**: 성능 문제 명확히 정의
2. **현황 분석**: 실행계획, 대기 이벤트 분석
3. **원인 파악**: 병목지점 식별
4. **해결방안 수립**: 여러 튜닝 방안 검토
5. **적용 및 검증**: 단계별 적용 후 효과 측정
6. **모니터링**: 지속적인 성능 관찰

**튜닝 우선순위**
1. 가장 자주 실행되는 SQL
2. 가장 많은 자원을 사용하는 SQL  
3. 응답시간이 긴 SQL
4. 사용자 불만이 많은 기능의 SQL