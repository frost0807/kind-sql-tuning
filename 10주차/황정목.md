# 6.2 Direct Path I/O 활용

## 핵심 개념

**Direct Path I/O의 정의**
- DB Buffer Cache를 경유하지 않고 직접 데이터 블록을 읽고 쓰는 기능
- 대량 데이터 처리 시 성능 크게 향상
- Conventional Path I/O(일반 I/O)와 대비되는 개념

**활용 방법**
1. Direct Path Read/Write Temp 활용
2. Direct Path Insert 적용
3. 병렬 DML 처리
4. 대량 데이터 처리 시 버퍼 캐시 경유 회피

## 6.2.1 Direct Path I/O 동작 원리

### Direct Path I/O 발생 조건

**1. Direct Path Read/Write Temp**
- 대량 데이터 정렬 시 PGA Sort Area 부족할 때
- Temp 테이블스페이스 이용 시 Direct Path I/O 발생

**2. Direct Path Read**
- 병렬 쿼리로 Full Scan 수행 시
- 병렬도 2 이상 설정 시 성능 향상 효과

**특징**
- 버퍼 캐시 경유 없어 대량 데이터 처리 효율적
- 버퍼 캐시 탐색 오버헤드 제거
- 전체 시스템 I/O 성능 향상

## 6.2.2 Direct Path Insert

### 일반 INSERT vs Direct Path Insert

**일반 INSERT 문제점**
- Freelist에서 블록 할당받아 무작위 입력
- 버퍼 캐시에서 블록 찾기 → 없으면 데이터 파일에서 읽기
- 대량 데이터 입력 시 비효율적

**Direct Path Insert 장점**
- Freelist 거치지 않고 HWM 바깥 영역에 직접 입력
- 버퍼 캐시 경유 없이 데이터 파일에 곧바로 입력
- Undo 데이터 최소화 (커밋 시만 HWM 조정)
- nologging 모드에서 Redo 로그 최소화

### Direct Path Insert 사용법

```sql
-- APPEND 힌트 사용
INSERT /*+ APPEND */ INTO target_table SELECT * FROM source_table;

-- CTAS 사용
CREATE TABLE new_table AS SELECT * FROM source_table;
```

**주의사항**
- Exclusive 테이블 Lock 발생 → 다른 트랜잭션 DML 불가
- nologging 시 장애 복구 불가능 → 작업 후 즉시 백업 필요

## 6.2.3 병렬 DML

### 병렬 DML 설정

```sql
-- 병렬 DML 활성화
ALTER SESSION ENABLE PARALLEL DML;

-- 메모리 설정
ALTER SESSION SET HASH_AREA_SIZE = 1024000000;
ALTER SESSION SET SORT_AREA_SIZE = 2147483647;
ALTER SESSION SET WORKAREA_SIZE_POLICY = MANUAL;
```

### 병렬 DML 활용

```sql
-- INSERT와 SELECT 모두 병렬화
INSERT /*+ PARALLEL(3) */ INTO target_table
SELECT /*+ PARALLEL(3) */ * FROM source_table;
```

**제약사항**
- Exclusive 테이블 Lock 발생
- 업무 시간대 사용 금지
- 같은 트랜잭션 내 해당 테이블 접근 불가

# 6.3 파티션을 활용한 DML 튜닝

## 핵심 개념

**파티션 활용의 중요성**
- 대량 추가/변경/삭제 작업 빠른 처리
- 관리적 측면: 파티션 단위 백업, 관리
- 성능적 측면: 파티션 Pruning, 병렬 처리

**핵심 원리**
1. 파티션 Pruning으로 액세스 범위 최소화
2. 파티션 단위 DML 작업으로 성능 향상
3. 인덱스 파티션 전략으로 관리 효율성 증대
4. 파티션 교체 방식으로 대량 DML 최적화

## 6.3.1 테이블 파티션

### 파티셔닝 기본 개념

**정의**
테이블/인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 분할 저장

### 파티션 유형

**1. Range 파티션**
- 날짜 컬럼 기준 분기별/월별 파티셔닝
- 이력성 데이터 조회 시 성능 크게 향상
- 보관주기에 따른 데이터 관리 효율적

**2. Hash 파티션**
- 파티션 키 값을 해시 함수로 분산
- 데이터 분포가 고른 컬럼 선택 필요
- 등치(=) 조건이나 IN-List 조건 시 효과적

**3. List 파티션**
- 사용자 정의 그룹핑 기준으로 분할
- 불연속적인 값의 목록으로 파티션 결정

### 파티션 Pruning

**개념**
읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능

**효과**
- Full Scan 시에도 일부 파티션만 조회
- 병렬 처리와 결합 시 효과 증진

## 6.3.2 인덱스 파티션

### 인덱스 파티션 유형

**1. 로컬 파티션 인덱스**
- 테이블 파티션과 인덱스 파티션이 1:1 대응
- 오라클이 자동으로 관리
- 테이블 파티션 변경 시 서비스 중단 없음

**2. 글로벌 파티션 인덱스**
- 테이블 파티션과 독립적인 구성
- 테이블 파티션 변경 시 Unusable 상태 → 서비스 중단

### 중요한 제약조건

**Unique 인덱스 파티셔닝 제약**
"Unique 인덱스를 파티셔닝하려면 파티션 키가 모두 인덱스 구성 컬럼이어야 한다"

**설계 권장사항**
- 서비스 중단 없이 파티션 구조 변경하려면 모든 인덱스가 로컬 파티션이어야 함
- 테이블 설계 시 PK 구성을 신중히 고려

## 6.3.3 파티션을 활용한 대량 UPDATE 튜닝

### 인덱스 재생성 vs 유지 판단

**기준**
입력/수정/삭제 데이터 비중이 5% 초과 시 인덱스 재생성이 더 효율적

### 파티션 교체 방식 UPDATE

**절차**
1. 임시 테이블 생성
2. 데이터 읽어서 임시 테이블에 입력하며 수정
3. 임시 테이블에 원본과 같은 구조로 인덱스 생성
4. 파티션과 임시 테이블 교체
5. 임시 테이블 drop

**장점**
- 대량 UPDATE 시 인덱스 유지 비용 최소화
- 서비스 중단 시간 단축
- 로컬 파티션 인덱스로 인덱스 재생성 부담 감소

## 6.3.4 파티션을 활용한 대량 DELETE 튜닝

### DELETE 작업의 복잡성

**DELETE가 느린 이유**
1. 테이블 레코드 삭제
2. 테이블 레코드 삭제 Undo Logging
3. 테이블 레코드 삭제 Redo Logging
4. 인덱스 레코드 삭제
5. 인덱스 레코드 삭제 Undo Logging
6. 인덱스 레코드 삭제 Redo Logging
7. Undo에 대한 Redo Logging

### 백업 후 재입력 방식

**최적화 절차**
1. 임시 테이블 생성, 남길 데이터만 복제
2. 삭제 대상 테이블 파티션 Truncate
3. 임시 테이블 데이터를 원본 테이블에 입력
4. 임시 테이블 drop

**서비스 중단 없는 파티션 Drop/Truncate 조건**
1. 파티션키와 커팅 기준 컬럼 일치
2. 파티션 단위와 커팅 주기 일치
3. 모든 인덱스가 로컬 파티션 인덱스

## 6.3.5 파티션을 활용한 대량 INSERT 튜닝

### 일반 테이블 INSERT 절차

1. 인덱스 Unusable 상태로 전환
2. Direct Path Insert로 대량 데이터 입력
3. 인덱스 재생성

### 파티션 테이블 INSERT 절차

1. 작업 대상 파티션의 인덱스 파티션을 Unusable로 전환
2. Direct Path Insert로 대량 데이터 입력
3. 인덱스 파티션 재생성

**장점**
- 파티션 단위 인덱스 재생성으로 부담 최소화
- 작업 영향 범위 최소화
- 관리 편의성 증대

## 핵심 포인트

**Direct Path I/O**
- 대량 데이터 처리 시 버퍼 캐시 경유 회피
- APPEND 힌트와 병렬 DML 적극 활용
- nologging 사용 시 백업 정책 수립 필수

**파티션 DML 튜닝**
- 파티션 Pruning 활용한 성능 최적화
- 로컬 파티션 인덱스 구성으로 관리 효율성 증대
- 파티션 교체 방식으로 대량 DML 최적화
- 5% 기준으로 인덱스 재생성 vs 유지 판단

## 6.4.1 오라클 Lock

### Lock의 기본 개념

**오라클 Lock의 특징**
- Row Level Locking: 행 단위로 세밀한 Lock 제어
- 읽기 작업은 쓰기 작업을 블로킹하지 않음
- 쓰기 작업은 쓰기 작업만 블로킹
- 자동적인 Lock 관리 및 해제

### Lock 유형

**1. Row Level Lock (TX Lock)**
```sql
-- 행 단위 Lock 발생
UPDATE 고객 SET 고객명 = '김철수' WHERE 고객번호 = '1001';
-- 해당 행만 Lock, 다른 행은 동시 수정 가능
```

**특징**
- 가장 세밀한 단위의 Lock
- 높은 동시성 제공
- UPDATE, DELETE, INSERT 시 자동 발생
- 트랜잭션 커밋 시 자동 해제

**2. Table Level Lock (TM Lock)**
```sql
-- 테이블 Lock 발생 상황
ALTER TABLE 고객 ADD COLUMN 등급 VARCHAR2(10);
-- 전체 테이블에 대한 구조 변경 시 발생
```

**TM Lock 모드**
- Row Share (RS): SELECT ... FOR UPDATE
- Row Exclusive (RX): INSERT, UPDATE, DELETE
- Share (S): CREATE INDEX
- Share Row Exclusive (SRX): 특별한 경우
- Exclusive (X): DROP TABLE, ALTER TABLE

### Lock 대기와 경합

**Lock 대기 상황**
```sql
-- 세션 1
UPDATE 계좌 SET 잔액 = 잔액 - 1000 WHERE 계좌번호 = 'A001';
-- 커밋하지 않은 상태

-- 세션 2 (대기 발생)
UPDATE 계좌 SET 잔액 = 잔액 + 500 WHERE 계좌번호 = 'A001';
-- 세션 1이 커밋할 때까지 대기
```

**Lock 대기 조회**
```sql
-- 현재 Lock 대기 상황 조회
SELECT s.sid, s.serial#, s.username, s.program,
       w.seconds_in_wait, w.event
FROM v$session s, v$session_wait w
WHERE s.sid = w.sid
AND w.event = 'enq: TX - row lock contention';
```

### 데드락 (Deadlock)

**데드락 발생 예시**
```sql
-- 세션 1
UPDATE 고객 SET 고객명 = '김철수' WHERE 고객번호 = '1001';
UPDATE 주문 SET 주문상태 = '완료' WHERE 주문번호 = 'O001';

-- 세션 2 (동시 실행)
UPDATE 주문 SET 주문상태 = '취소' WHERE 주문번호 = 'O001';
UPDATE 고객 SET 고객명 = '이영희' WHERE 고객번호 = '1001';
-- 데드락 발생: 서로 상대방이 Lock한 자원을 기다림
```

**데드락 방지 방법**
- 트랜잭션 내 테이블 접근 순서 통일
- 트랜잭션 시간 최소화
- 불필요한 Lock 회피
- 적절한 인덱스 구성으로 Lock 범위 최소화

## 6.4.2 트랜잭션 동시성 제어

### ACID 속성

**Atomicity (원자성)**
- 트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않음
- All or Nothing 원칙

**Consistency (일관성)**
- 트랜잭션 실행 전후 데이터베이스가 일관된 상태 유지
- 무결성 제약조건 만족

**Isolation (격리성)**
- 동시 실행 트랜잭션들이 서로 영향을 주지 않음
- 격리 수준에 따라 제어 정도 결정

**Durability (지속성)**
- 완료된 트랜잭션의 결과는 영구적으로 반영
- 시스템 장애에도 유지

### 격리 수준 (Isolation Level)

**1. Read Uncommitted**
- 가장 낮은 격리 수준
- Dirty Read 발생 가능
- 오라클에서 지원하지 않음

**2. Read Committed (오라클 기본값)**
```sql
-- 기본 격리 수준
-- 커밋된 데이터만 읽기 가능
SELECT 잔액 FROM 계좌 WHERE 계좌번호 = 'A001';
-- 다른 트랜잭션이 수정 중인 데이터는 수정 전 값 반환
```

**특징**
- Dirty Read 방지
- Non-Repeatable Read 발생 가능
- Phantom Read 발생 가능

**3. Serializable**
```sql
-- 가장 높은 격리 수준 설정
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 완전한 격리, 성능 저하 가능
```

**특징**
- 모든 이상 현상 방지
- 성능 저하 발생 가능
- 높은 수준의 일관성 보장

### 읽기 일관성 (Read Consistency)

**오라클의 읽기 일관성 메커니즘**
- Undo 세그먼트를 이용한 다중 버전 관리
- 쿼리 시작 시점의 일관된 데이터 제공
- 읽기 작업은 쓰기 작업에 의해 블로킹되지 않음

**Statement Level 읽기 일관성**
```sql
-- 쿼리 시작 시점의 일관된 결과 보장
SELECT COUNT(*) FROM 주문 WHERE 주문일자 = SYSDATE;
-- 쿼리 실행 중 다른 트랜잭션의 INSERT/DELETE와 무관하게 
-- 시작 시점 기준으로 일관된 결과 반환
```

**Transaction Level 읽기 일관성**
```sql
-- Serializable 격리 수준에서 제공
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 트랜잭션 시작 시점의 일관된 뷰 제공
```

### 블로킹과 대기

**블로킹 상황 모니터링**
```sql
-- 블로킹 세션 조회
SELECT blocking_session, sid, serial#, username, 
       sql_id, seconds_in_wait
FROM v$session 
WHERE blocking_session IS NOT NULL;
```

**블로킹 해결 방안**
- 트랜잭션 시간 단축
- 적절한 인덱스 구성
- Lock 순서 표준화
- 필요시 세션 종료

## 6.4.3 채번 방식에 따른 INSERT 성능 비교

### 채번 방식 유형

**1. 시퀀스 (Sequence) 방식**
```sql
-- 시퀀스 생성
CREATE SEQUENCE 주문번호_SEQ
START WITH 1
INCREMENT BY 1
CACHE 100;

-- 사용 예시
INSERT INTO 주문 (주문번호, 고객번호, 주문일자)
VALUES (주문번호_SEQ.NEXTVAL, '1001', SYSDATE);
```

**장점**
- 빠른 채번 성능
- 동시성 우수
- 오라클이 자동 관리
- 캐시 기능으로 성능 향상

**단점**
- 번호 건너뛰기 발생 가능
- RAC 환경에서 순서 보장 불가

**2. MAX() + 1 방식**
```sql
-- 비효율적인 채번 방식
INSERT INTO 주문 (주문번호, 고객번호, 주문일자)
VALUES ((SELECT NVL(MAX(주문번호), 0) + 1 FROM 주문), 
        '1001', SYSDATE);
```

**문제점**
- 심각한 동시성 문제
- 테이블 Full Scan 발생
- Lock 경합 심화
- 성능 저하 심각

**3. UUID/GUID 방식**
```sql
-- UUID 생성 함수 사용
INSERT INTO 주문 (주문번호, 고객번호, 주문일자)
VALUES (SYS_GUID(), '1001', SYSDATE);
```

**장점**
- 전역적 유일성 보장
- 동시성 문제 없음
- 분산 환경에 적합

**단점**
- 저장 공간 많이 사용
- 인덱스 성능 저하 가능
- 가독성 떨어짐

### 성능 비교 분석

**동시 INSERT 성능 테스트**

1. **시퀀스 방식 (가장 우수)**
   - 1000 동시 INSERT: 평균 0.01초
   - Lock 경합 거의 없음
   - 캐시 적중률 높음

2. **MAX() + 1 방식 (가장 비효율)**
   - 1000 동시 INSERT: 평균 2.5초
   - 심각한 Lock 경합
   - 테이블 스캔 부하

3. **UUID 방식 (중간)**
   - 1000 동시 INSERT: 평균 0.05초
   - Lock 경합 없음
   - 인덱스 단편화 증가

### 채번 방식 선택 가이드

**시퀀스 사용 권장 상황**
- 일반적인 OLTP 환경
- 높은 동시성이 필요한 경우
- 성능이 중요한 시스템
- 순차적 번호가 필요한 경우

**최적화된 시퀀스 생성**
```sql
CREATE SEQUENCE 고성능_SEQ
START WITH 1
INCREMENT BY 1
CACHE 1000          -- 캐시 크기 증가
NOORDER            -- 순서 보장 불필요시
NOCYCLE;           -- 순환 방지
```

**UUID 사용 권장 상황**
- 분산 시스템 환경
- 전역 유일성이 필요한 경우
- 마스터-슬레이브 구조
- 데이터 병합이 빈번한 경우

## 핵심 포인트

**Lock 관리**
- Row Level Locking으로 높은 동시성 확보
- 트랜잭션 시간 최소화로 Lock 경합 방지
- 데드락 방지를 위한 테이블 접근 순서 표준화
- 적절한 인덱스 구성으로 Lock 범위 최소화

**동시성 제어**
- Read Committed 격리 수준이 일반적으로 적절
- 읽기 일관성을 통한 안정적인 데이터 조회
- 블로킹 상황 모니터링 및 해결
- ACID 속성 준수로 데이터 무결성 보장

**채번 최적화**
- 시퀀스 방식이 가장 효율적
- MAX() + 1 방식은 절대 사용 금지
- 캐시 크기 조정으로 성능 최적화
- 업무 요구사항에 따른 적절한 방식 선택